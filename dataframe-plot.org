* dataframe-plot

dataframe plots and operations.

Charts for dataframes built with chart-svg.

- write main chart functions
  - write with a [Double] data type, HistogramOption style.
  - example

- write `D.plot df`
  - Using dataframe metadata for default axis titles

* Imports

#+begin_src haskell-ng :results output
:r

:set -XNoImplicitPrelude
:set -XImportQualifiedPost
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedLabels
:set -XOverloadedStrings
:set -XTupleSections
:set -XQuasiQuotes

-- base, text & bytestring encoding (compatability check, also)
import Prelude as P
import NumHask.Prelude qualified as N
import NumHask.Space qualified as N
import Control.Category ((>>>))
import Data.Function
import Data.Maybe
import Data.Bool
import Data.List qualified as List
import Control.Monad
import Data.Bifunctor
import Data.ByteString.Char8 qualified as C
import Data.Text qualified as T

-- prettyprinter (dev help)
import Prettyprinter

-- common dataframe imports
import DataFrame qualified as D
import DataFrame.Functions qualified as F
import DataFrame.Internal.Column qualified as D
import DataFrame.Internal.Expression qualified as D
import DataFrame.Internal.Statistics qualified as D
import qualified Data.Vector.Algorithms.Intro as VA
import qualified Data.Vector.Unboxed as VU
import qualified Data.Vector.Unboxed.Mutable as VUM
import DataFrame.Synthesis qualified as S

-- common chart-svg imports
import Chart
import Prettychart
import Chart.Examples
import Optics.Core hiding ((|>),(<|))
import Control.Lens qualified as Lens
import Data.Data.Lens qualified as Lens

-- random variates
import System.Random.Stateful
import System.Random.MWC
import System.Random.MWC.Distributions

-- dev helpers
import Perf
import Flow
import Data.FormatN
import Data.Mealy
import Data.Mealy.Simulate

-- dataframe chart-svg interface
import DataFrame.Plot

-- example data from https://www.kaggle.com/competitions/playground-series-s5e11
dfTest <- D.readCsv "other/s5e11/test.csv"
v = F.col @Double "value"
df0 = mempty |> D.insert "item" ["person","woman","man","camera","tv"] |> D.insert "value" [20,23.1,31,16,10]
xs = D.columnAsList v df0
xs' = (/ sum xs) <$> xs
df = D.insert "prop" xs' df0

-- initialize a random seed
-- uniformRM (0,1) g :: IO Double
g <- initialize $ VU.fromList [1,2,3]

rend = writeChartOptions

#+end_src

#+RESULTS:
#+begin_example
Configuration is affected by the following files:
- cabal.project
Build profile: -w ghc-9.12.2 -O1
In order, the following will be built (use -v for more details):
 - dataframe-plot-0.1.0.0 (interactive) (lib) (configuration changed)
Configuring library for dataframe-plot-0.1.0.0...
Preprocessing library for dataframe-plot-0.1.0.0...
GHCi, version 9.12.2: https://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling DataFrame.Plot   ( src/DataFrame/Plot.hs, interpreted )
Ok, one module loaded.
Ok, one module reloaded.
#+end_example

* Live charts

This gives you a browser page and live charting capabilities.

#+begin_src haskell-ng
-- live charts
(display, quit) <- startChartServer Nothing
disp x = display $ x & set (#markupOptions % #markupHeight) (Just 400) & set (#hudOptions % #frames % ix 1 % #item % #buffer) 0.1

#+end_src

#+RESULTS:
: Setting phasers to gshtcuin>. .. (port 9160) (ctrl-c tog hqcuii>t )

http://localhost:9160/

testing, testing; one, two, three

#+begin_src haskell-ng
disp lineExample
#+end_src

#+RESULTS:
: True

* linRegress

#+begin_src haskell-ng :results output
beamSearch ::
    DataFrame ->
    -- | Parameters of the beam search.
    BeamConfig ->
    -- | Examples
    TypedColumn Double ->
    -- | Constants
    [Expr Double] ->
    -- | Conditions
    [Expr Bool] ->
    -- | Programs
    [Expr Double] ->
    Maybe (Expr Double)


#+end_src

** notes

- single pop not batch
- MeanSquaredError in config

*** loop

#+begin_src haskell-ng :results output
import Data.Mealy.Simulate
:t rvsp
#+end_src

#+RESULTS:
: rvsp :: Gen RealWorld -> Int -> Double -> IO [(Double, Double)]

8 secs

#+begin_src haskell-ng :results output
rvs <- rvsp g 1000 0.7
xs = fmap ((0.2 +) . (0.2 *). fst) rvs
ys = zipWith (+) (fmap (2*) <| zipWith (*) xs xs) (fmap snd rvs)
df = mempty |> D.insert "x" xs |> D.insert "y" ys
D.correlation "x" "y" df
target = "y"
tc c = either (error . show) id (D.interpret df (F.col c))
targetMean = D.mean (F.col @Double target) df
constants = S.percentiles (D.exclude [target] df) ++ [D.Lit 10, D.Lit 1, D.Lit 0.1, D.Lit targetMean]
run = S.beamSearch (D.exclude [target] df) (S.BeamConfig 3 100 S.MeanSquaredError True) (tc target) constants [] []
run
#+end_src

#+RESULTS:
: Just 0.7590111100680493
: Best loss: Just (Just (-0.9044022591133772)) Just (col @Double "x")
: Best loss: Just (Just (-0.7453602422628713)) Just (mult (lit (2.0)) (col @Double "x"))
: Best loss: Just (Just (-0.5258084000808123)) Just (divide (sub (col @Double "x") (lit (0.1927546639480596))) (lit (0.21381376000000007)))
: Just (divide (sub (col @Double "x") (lit (0.1927546639480596))) (lit (0.21381376000000007)))

#+begin_src haskell-ng :results output
:set -Wno-incomplete-uni-patterns
(Just e) = run
e
putStrLn (S.prettyI e)
#+end_src

#+RESULTS:
: (divide (sub (col @Double "x") (lit (0.1927546639480596))) (lit (0.21381376000000007)))
: ((x - 0.193) / 0.214)

#+begin_src haskell-ng :results output
(show . typeOf . D.Lit @Double $ 1.2)
#+end_src

#+RESULTS:
: "Expr Double"

#+begin_src haskell-ng :results output
import Text.Read
:t readMaybe
#+end_src

#+RESULTS:
: readMaybe :: Read a => String -> Maybe a


* Examples

** Histogram

At defaults

#+begin_src haskell-ng :results output
df = dfTest

-- This doesnt work
-- c0 = D.columnAsList "interest_rate" df
c0 = D.columnAsList @Double "interest_rate" df
h = histogram defaultHistogramOptions c0

:t h
disp h
rend "other/histogram.svg" h

#+end_src

#+RESULTS:
: h :: ChartOptions
: True

[[file:other/histogram.svg]]

skinny, with a title & no axis

#+begin_src haskell-ng :results output
h2 = h |> setTitle "penguins" |> set (#hudOptions % #axes) [] |> set (#markupOptions % #chartAspect) (FixedAspect 0.5)

disp h2
rend "other/histogram2.svg" h2

#+end_src

#+RESULTS:
: True

[[file:other/histogram2.svg]]


#+begin_src haskell-ng :results output
h3 = h |> over (#chartTree % chart' % #chartData % rectData') (fmap (fmap N.flipAxes))

disp h3
rend "other/histogram3.svg" h3

#+end_src

#+RESULTS:
: True

[[file:other/histogram3.svg]]

#+begin_src haskell-ng :results output
:t N.flipAxes
#+end_src

#+RESULTS:
: N.flipAxes :: Rect a -> Rect a

** Scatter

single scatter: side-by-side comparison

#+begin_src haskell-ng :results output
df = dfTest
xs = take 100 $ D.columnAsList "interest_rate" df
ys = D.columnAsList "loan_amount" df
ch = scatter (defaultScatterOptions |> set (#styles % each % #color % opac') 0.2 |> set (#styles % each % #borderColor % opac') 0.5 |> set (#styles % each % #size) 0.05 |> set (#styles % each % #glyphShape) SquareGlyph) xs ys
ch' = scatter (defaultScatterOptions |> set (#styles % each % #color % opac') 0.2 |> set (#styles % each % #borderColor % opac') 0.5 |> set (#styles % each % #size) 0.05 |> set (#styles % each % #glyphShape) CircleGlyph) xs ys
chs = horiCO AlignMid 0.1 [ch', ch]
-- rend "other/scatter1.svg" chf
disp chs

#+end_src

#+RESULTS:
: True

Adding titles


#+begin_src haskell-ng :results output
disp <| (ch |> over #hudOptions (addTitle PlaceLeft 0.05 "loan_amount" .> addTitle PlaceBottom 0.05 "interest_rate" .> set (#titles % each % #item % #buffer) 0.05))
#+end_src

multi-scatter

gender as a classifier

#+begin_src haskell-ng :results output
df = dfTest
xs = D.columnAsList "interest_rate" df
ys = D.columnAsList "loan_amount" df
gs = D.columnAsList "gender" df
ch = scatter (defaultScatterOptions |> set (#styles % each % #color % opac') 0.2 |> set (#styles % each % #borderColor % opac') 0.5 |> set (#styles % each % #size) 0.05 |> set (#styles % each % #glyphShape) SquareGlyph) xs ys
ch' = scatter (defaultScatterOptions |> set (#styles % each % #color % opac') 0.2 |> set (#styles % each % #borderColor % opac') 0.5 |> set (#styles % each % #size) 0.05 |> set (#styles % each % #glyphShape) CircleGlyph) xs ys
chs = horiCO AlignMid 0.1 [ch', ch]
-- rend "other/scatter1.svg" chf
disp chs

#+end_src

#+RESULTS:
: True

#+begin_src haskell-ng :results output
import Data.Map.Strict qualified as Map
zs = zip3 xs ys gs :: [(Double, Double, T.Text)]
fst <$> cs

collectP p q zs = foldl' (\acc z -> Map.insertWith (<>) (p z) [q z] acc) Map.empty zs
ps = collectP (\(_,_,x)->x) (\(x,y,_) -> Point x y) zs

c = scatters defaultScatterOptions (Map.toList ps)

makeLegend labels cs = [ Priority 12 $ defaultLegendOptions & set #scaleP ScalePX & set #place PlaceRight & set #legendCharts (zipWith (\t c -> (t, [c])) labels cs)]

scatterLegend = set #legends (makeLegend (fst <$> cs) ((\s -> GlyphChart s [zero]) <$> (view #styles defaultScatterOptions)))

disp (c |> over #hudOptions scatterLegend)

#+end_src

#+RESULTS:
: ["Female","Male","Other"]
: True

*** a ScatterSchema?

#+begin_src haskell-ng :results output
scatter :: ScatterOptions -> DataFrame -> ChartOptions
#+end_src

Does scatter mean a single styled series of points or a multiply-coloured cast of penguins can be included in ScatterOptions? It could be:

#+begin_src haskell-ng :results output
defaultScatterOptions = ScatterOptions ScatterSchema

data ScatterSchema = [("x", "interest_rate"), ("y", "loan_amount"), ("colors", Just "gender")]

#+end_src

which can mean that the x and y data for Points is in the columns "interest_rate" and "loan_amount" and the groupings (for color) are in column "gender" (but could be absent).

** ToDo Line

  - multiple series, markers, dashed lines
** ToDo Bar

  - simple, grouped, stacked, horizontal

** ToDo HeatMap
** Pie

#+begin_src haskell-ng :results output
import DataFrame.Internal.Expression (interpret)
import DataFrame.Internal.Column (unwrapTypedColumn)

df = dfTest
:set -Wno-incomplete-uni-patterns
(Right c) = interpret df (F.col (D.columnNames df !! 0))
-- D.hasElemType @T.Text (unwrapTypedColumn c)
-- D.columnNames df
-- (either (error . show) id)
txts = filter (\c -> interpret df (F.col c) |> either (show .> error) id |> unwrapTypedColumn |> D.hasElemType @T.Text) (D.columnNames df)
-- txts

-- couldn't quite get there with the count
-- :t F.count . F.col <$> txts
-- cs = unwrapTypedColumn . either (show .> error) id . interpret df . F.count . F.col <$> txts
import DataFrame.Internal.DataFrame qualified as X
import DataFrame.Internal.Column qualified as X
import Data.Map.Strict qualified as Map
-- :t fold countM
cs = (\c -> X.unsafeGetColumn c df |> X.toList |> fold countM |> Map.toList) <$> txts :: [[((T.Text,Int))]]
:t cs

-- how do you solve this properly? arrows?
xs = fmap fst <$> cs
ys = fmap (fromIntegral . snd) <$> cs
prop xs = (/ sum xs) <$> xs
cs' = zipWith zip xs (fmap prop ys)
pies = pie defaultPieOptions <$> cs'

:t pies

ch = stackCO 3 AlignMid AlignMid 0.1 pies
disp ch
#+end_src

#+RESULTS:
: cs :: [[(T.Text, Int)]]
: pies :: [ChartOptions]
: True

#+begin_src haskell-ng :results output
pies' = zipWith (\f p -> p |> over #hudOptions f) (addTitle PlaceBottom 0.1 <$> txts) pies
ch' = stackCO 2 AlignMid AlignMid 0.1 (pies' |> fmap (set (#markupOptions % #chartAspect) (ChartAspect)))
disp ch'
rend "other/pies.svg" ch'

#+end_src

#+RESULTS:
: True

[[file:other/pies.svg]]

** Pie (2)

#+begin_src haskell-ng :results output
-- example data from https://www.kaggle.com/competitions/playground-series-s5e11
dfTest <- D.readCsv "other/s5e11/test.csv"
v = F.col @Double "value"
df0 = mempty |> D.insert "item" ["person","woman","man","camera","tv"] |> D.insert "value" [20,23.1,31,16,10]
xs = D.columnAsList @Double "value" df0
xs' = (/ sum xs) <$> xs
df = D.insert "prop" xs' df0
#+end_src

#+RESULTS:


feature set:

- exploded. Tip of the secant is offset from the origin (eg all of them or individually for emphasis).
- secants are bordered and styled.
- donuts are secants with another chord cut out at the origin.
- does it have to be a circle? How about a square and an origin point.
- area represents size (as a percentage of sum).

A pie chart is a type of 'size' chart where the size of a shape represents data magnitudes.

#+begin_src haskell-ng :results output
ls = T.pack <$> D.columnAsList @String "item" df
vs = D.columnAsList @Double "prop" df
co = pie defaultPieOptions (zip ls vs)
disp co
rend "other/pie.svg" co
#+end_src

#+RESULTS:

[[file:other/pie.svg]]

** boxPlot

#+begin_src haskell-ng :results output
c0 = D.columnAsList "interest_rate" df
ch = boxPlot defaultBoxPlotOptions c0
disp ch
#+end_src

#+RESULTS:
: True

[[file:other/box1.svg]]
**** box plot construction

A box plot is:

- (maybe) a vertical tick at the min
- a LineChart from min to q1
- a RectChart from q1 to q2
- a RectChart from q2 to q3
- a LineChart q3 to max
- (maybe) a vertical tick at the max

#+begin_src haskell-ng :results output
l1 = LineChart defaultLineStyle [[Point (q4s !! 0) 0.5, Point (q4s !! 1) 0.5]]
l2 = LineChart defaultLineStyle [[Point (q4s !! 3) 0.5, Point (q4s !! 4) 0.5]]
r1 = RectChart defaultRectStyle [Rect (q4s !! 1) (q4s !! 2) 0 1]
r2 = RectChart defaultRectStyle [Rect (q4s !! 2) (q4s !! 3) 0 1]
#+end_src

**** vertical box plot constrcution

#+begin_src haskell-ng :results output
qs = q4s
l1 = LineChart defaultLineStyle [[Point 0.5 (qs !! 0), Point 0.5 (qs !! 1)]]
l2 = LineChart defaultLineStyle [[Point 0.5 (qs !! 3), Point 0.5 (qs !! 4)]]
r1 = RectChart defaultRectStyle [Rect 0 1 (qs !! 1) (qs !! 2)]
r2 = RectChart defaultRectStyle [Rect 0 1 (qs !! 2) (qs !! 3)]
#+end_src

** multiple boxPlots

#+begin_src haskell-ng :results output
import DataFrame.Internal.Expression (interpret)
import DataFrame.Internal.Column (unwrapTypedColumn)

df = dfTest
:set -Wno-incomplete-uni-patterns
(Right c) = interpret df (F.col (D.columnNames df !! 0))
-- D.hasElemType @T.Text (unwrapTypedColumn c)
-- D.columnNames df
-- (either (error . show) id)
dbls = filter (\c -> interpret df (F.col c) |> either (show .> error) id |> unwrapTypedColumn |> D.hasElemType @Double) (D.columnNames df)
-- txts

-- couldn't quite get there with the count
-- :t F.count . F.col <$> txts
-- cs = unwrapTypedColumn . either (show .> error) id . interpret df . F.count . F.col <$> txts
import DataFrame.Internal.DataFrame qualified as X
import DataFrame.Internal.Column qualified as X
import Data.Map.Strict qualified as Map

xss = (\c -> D.columnAsList @Double c df) <$> dbls
cs = boxPlot defaultBoxPlotOptions <$> xss
boxCharts = zipWith (\c t -> c |> over #hudOptions (addTitle PlaceBottom 0.03 t)) cs dbls
c = horiCO AlignMid 0.1 boxCharts
#+end_src

#+RESULTS:
: True

** stackedBar

#+begin_src haskell-ng :results output
ls = T.pack <$> D.columnAsList @String "item" df
vs = D.columnAsList @Double "prop" df
c = stackedBar (defaultStackedBarOptions |> set (#itemStyles % each % _1 % #color % opac') 0.4) "item" (zip ls vs)
disp c
#+end_src

#+RESULTS:
: True

*** multiple stackedBar

#+begin_src haskell-ng :results output
import DataFrame.Internal.Expression (interpret)
import DataFrame.Internal.Column (unwrapTypedColumn)

df = dfTest
:set -Wno-incomplete-uni-patterns
(Right c) = interpret df (F.col (D.columnNames df !! 0))
-- D.hasElemType @T.Text (unwrapTypedColumn c)
-- D.columnNames df
-- (either (error . show) id)
txts = filter (\c -> interpret df (F.col c) |> either (show .> error) id |> unwrapTypedColumn |> D.hasElemType @T.Text) (D.columnNames df)
-- txts

-- couldn't quite get there with the count
-- :t F.count . F.col <$> txts
-- cs = unwrapTypedColumn . either (show .> error) id . interpret df . F.count . F.col <$> txts
import DataFrame.Internal.DataFrame qualified as X
import DataFrame.Internal.Column qualified as X
import Data.Map.Strict qualified as Map
-- :t fold countM
cs = (\c -> X.unsafeGetColumn c df |> X.toList |> fold countM |> Map.toList) <$> txts :: [[((T.Text,Int))]]
:t cs

-- how do you solve this properly? arrows?
xs = fmap fst <$> cs
ys = fmap (fromIntegral . snd) <$> cs
prop xs = (/ sum xs) <$> xs
cs' = zipWith zip xs (fmap prop ys)
-- sbars = stackedBar defaultStackedBarOptions <$> cs'
stackedCharts = zipWith (\t cs -> stackedBar (defaultStackedBarOptions |> set (#itemStyles % each % _1 % #color % opac') 0.2) t cs) txts cs'
c = horiCO AlignMid 0.1 stackedCharts

disp c
#+end_src

#+RESULTS:
: cs :: [[(T.Text, Int)]]
: True

*** onLoad

#+begin_src haskell-ng :results output
disp (horiCO AlignRight 0.1 (stackedCharts <> boxCharts))
#+end_src

#+RESULTS:
: True


** littleuns

#+begin_src haskell-ng :results output
p = [0..4]
op = defaultPieOptions |> over (#secants % each % #pathStyle % #color % opac') (const 0.7)
offSecant = defaultSecantOptions |> set (#pathStyle % #color % opac') 0.04 |> set (#textStyle % #color % opac') zero
cs = fmap (\x -> piePlot (switchOffs x offSecant op) (zip ls vs)) (List.subsequences p)
cts = cs |> fmap (view #chartTree)
-- littleuns
cts' = projectChartTree (fmap (0.06*) one) <$> cts

-- random points
xs <- replicateM (length cs) (uniformDouble01M g) :: IO [Double]
ys <- replicateM (length cs) (uniformDouble01M g) :: IO [Double]
ps = zipWith Point xs ys

-- littleuns at random points
cts'' = zipWith (\p ct -> over charts' (fmap (moveChart p)) ct) ps cts'

-- littleuns with no text at random points
noTextCt ct = mempty |> set #chartTree ct |> noText |> view #chartTree
ct1 = noTextCt <$> cts''

bl = named "blank" [BlankChart defaultStyle [Rect 0 1 0 1]]

ct = ct1!!2 <> bl

ho = defaultHudOptions |> set (#axes % each % #item % #ticks % #tick % tickExtend') (Just NoTickExtend) |> set (#axes % each % #item % #ticks % #tick) (TickPlaced [(0,"0"),(0.5,"0.5"),(1,"1")])

disp (mempty |> set #hudOptions ho |> set (#markupOptions % #chartAspect) ChartAspect |> set #chartTree (mconcat $ bl:ct1))

#+end_src

#+RESULTS:
: True

** GlyphPath


#+begin_src haskell-ng :results output
h1 = PathChart defaultPathStyle (svgToPathData "M0 180.664l60.222-90.332L0 0h45.166l60.222 90.332-60.222 90.332H0z")
h2 = PathChart defaultPathStyle (svgToPathData "M60.222 180.664l60.222-90.332L60.222 0h45.166L225.83 180.664h-45.166l-37.637-56.457-37.639 56.457H60.222z")
h3 = PathChart defaultPathStyle (svgToPathData "M205.757 127.971l-20.072-30.11 70.257-.002v30.112h-50.185zM175.647 82.805l-20.074-30.11 100.369-.002v30.112h-80.295z")

h1' = PathChart defaultPathStyle (svgToPathData "M0 180.664l60.222-90.332L0 0h45.166l60.222 90.332-60.222 90.332H0zM60.222 180.664l60.222-90.332L60.222 0h45.166L225.83 180.664h-45.166l-37.637-56.457-37.639 56.457H60.222z")

hbs = "M0 180.664l60.222-90.332L0 0h45.166l60.222 90.332-60.222 90.332H0zM60.222 180.664l60.222-90.332L60.222 0h45.166L225.83 180.664h-45.166l-37.637-56.457-37.639 56.457H60.222z"

disp <| (mempty |> set #chartTree (named "h1" ([h1'])))

:t PathGlyph hbs

gs = PathGlyph (svgToPathData hbs |> fmap (scalePath 0.01) |> pathDataToSvg)
gs
#+end_src

#+RESULTS:
: True
: PathGlyph hbs :: GlyphShape
: PathGlyph "M 0,1.8066 L 0,1.8066 L 0.6022,0.9033 L 0,0 L 0,0 L 0.4517,0 L 0.4517,0 L 1.0539,0.9033 L 0.4517,1.8066 L 0,1.8066 L 0,1.8066 M 0.6022,1.8066 L 0.6022,1.8066 L 1.2044,0.9033 L 0.6022,0 L 0.6022,0 L 1.0539,0 L 2.2583,1.8066 L 2.2583,1.8066 L 1.8066,1.8066 L 1.8066,1.8066 L 1.4303,1.2421 L 1.0539,1.8066 L 0.6022,1.8066 L 0.6022,1.8066"

#+begin_src haskell-ng :results output
<path d="M0 180.664l60.222-90.332L0 0h45.166l60.222 90.332-60.222 90.332H0z" fill="#F97E2F"/><path d="M60.222 180.664l60.222-90.332L60.222 0h45.166L225.83 180.664h-45.166l-37.637-56.457-37.639 56.457H60.222z" fill="#95653A"/><path d="M205.757 127.971l-20.072-30.11 70.257-.002v30.112h-50.185zM175.647 82.805l-20.074-30.11 100.369-.002v30.112h-80.295z" fill="#F97E2F"/></svg>
#+end_src



#+begin_src haskell-ng :results output
(defaultTitleOptions mempty & set (#style % #size) 0.06 & set #place PlaceBottom) (defaultTitleOptions mempty & set (#style % #size) 0.06 & set #buffer 0.1 & set #place PlaceLeft)
ho = defaultHudOptions & maybe id (\tx -> over #titles ((Priority 8 (view #titleX o & set #text tx)) :)) t0 & maybe id (\ty -> over #titles ((Priority 8 (view #titleY o & set #text ty)) :)) t1

#+end_src

#+begin_src haskell-ng :results output
gs = PathGlyph (svgToPathData hbs |> fmap (scalePath 0.1) |> pathDataToSvg)
color1 = Colour 0.976 0.494 0.184 0
color2 = Colour 0.584 0.399 0.227 1

xs = take 100 $ D.columnAsList "interest_rate" df
ys = take 100 $ D.columnAsList "loan_amount" df
ch = scatter (defaultScatterOptions |> set (#styles % each % #color % opac') 0.3 |> set (#styles % each % #borderColor % opac') 0.2 |> set (#styles % each % #size) 0.05 |> set (#styles % each % #glyphShape) CircleGlyph) xs ys
ch' = scatter (defaultScatterOptions |> set (#styles % each % #color % opac') 0.1 |> over (#styles % each % #color) (rgb color1) |> set (#styles % each % #borderColor % opac') 0.5 |> set (#styles % each % #size) 0.03 |> set (#styles % each % #glyphShape) gs) xs ys
chs = horiCO AlignMid 0.02 [ch', ch]
rend "other/scatter-path.svg" chs
disp chs

#+end_src

* perf

*** file read testing

It's a good chunky first example.

#+begin_src haskell-ng :results output
s <- readFile "other/test.csv"
length s
#+end_src

#+RESULTS:
: 23021430

#+begin_src haskell-ng :results output
rf = readFile "other/test.csv"
(m,n) <- tickIO (length <$> rf)
print n
toSecs m
#+end_src

#+RESULTS:
: 23021430
: 0.144087667

#+begin_src haskell-ng :results output
(m,df) <- tickIO (D.readCsv "other/test.csv")
print $ toSecs m
:t df
#+end_src

#+RESULTS:
: 0.944859458
: df :: DataFrame


Example data is  from https://www.kaggle.com/competitions/playground-series-s5e11
*** get a Column and compute quartiles.

#+begin_src haskell-ng :results output
c = (either (error . show) id) (columnAsDoubleVector "interest_rate" df)
:t c
q4s = VU.toList $ quantiles' (VU.fromList [0,1,2,3,4]) 4 c
:t q4s
q4s
#+end_src

#+RESULTS:
: c :: VU.Vector Double
: q4s :: [Double]
: [3.2,10.98,12.37,13.69,21.29]

* reference

Comparable python:

https://www.kaggle.com/code/ravitejagonnabathula/predicting-loan-payback

notebook best practice:

https://marimo.io/blog/lessons-learned

converting to ipynb:

https://pandoc.org/installing.html

#+begin_src sh :results output
pandoc readme.md -o mdata.ipynb
#+end_src

chart-svg api tree

https://hackage-content.haskell.org/package/chart-svg-0.8.2.1/docs/other/ast.svg

seaborn color palettes

https://seaborn.pydata.org/generated/seaborn.color_palette.html
