* mdata

This repo contains:

- a [[https://github.com/mchav/dataframe][dataframe]] example taken from a kaggle run.
- [[https://github.com/tonyday567/perf][perf]] which is being used to measure performance of common usage patterns.
- [[https://github.com/tonyday567/chart-svg][chart-svg]] | dataframe integration and development
- a live chart build using [[https://github.com/tonyday567/prettychart][prettychart]]
- some CI infrastructure to begin to measure integration.
- some pandoc conversion experiments: from org => markdown => ipynb
  (This is not catered for in nbconvert or jupytext wrt outputs)

* Imports

#+begin_src haskell-ng :results output
:r

:set -XNoImplicitPrelude
:set -XImportQualifiedPost
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedLabels
:set -XOverloadedStrings
:set -XTupleSections
:set -XQuasiQuotes

-- base, text & bytestring encoding (compatability check, also)
import Prelude as P
import NumHask.Prelude qualified as N
import NumHask.Space qualified as N
import Control.Category ((>>>))
import Data.Function
import Data.Maybe
import Data.Bool
import Data.List qualified as List
import Control.Monad
import Data.Bifunctor
import Data.ByteString.Char8 qualified as C
import Data.Text qualified as T

-- prettyprinter (dev help)
import Prettyprinter

-- common dataframe imports
import DataFrame qualified as D
import DataFrame.Functions qualified as F
import DataFrame.Internal.Expression qualified as D
import DataFrame.Internal.Statistics qualified as D
import qualified Data.Vector.Algorithms.Intro as VA
import qualified Data.Vector.Unboxed as VU
import qualified Data.Vector.Unboxed.Mutable as VUM

-- common chart-svg imports
import Chart
import Prettychart
import Chart.Examples
import Optics.Core hiding ((|>),(<|))
import Control.Lens qualified as Lens
import Data.Data.Lens qualified as Lens

-- dev helpers
import Perf
import Flow

-- functions not yet transferred elsewhere
import MData

-- example data from https://www.kaggle.com/competitions/playground-series-s5e11
df <- D.readCsv "data/s5e11/test.csv"

#+end_src

#+RESULTS:
#+begin_example
Configuration is affected by the following files:
- cabal.project
Build profile: -w ghc-9.12.2 -O1
In order, the following will be built (use -v for more details):
 - mdata-0.1.0.0 (interactive) (lib) (first run)
Preprocessing library for mdata-0.1.0.0...
GHCi, version 9.12.2: https://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling MData            ( src/MData.hs, interpreted )
Ok, one module loaded.
Ok, one module reloaded.
#+end_example

** Live charts

This gives you a browser page and live charting capabilities.

#+begin_src haskell-ng :results output
(display, quit) <- startChartServer (Just "mdata")
disp x = display $ x & set (#markupOptions % #markupHeight) (Just 250) & set (#hudOptions % #frames % ix 1 % #item % #buffer) 0.1
#+end_src

#+RESULTS:
: Setting phasers to stugnh.c.i.>  (port 9160) (ctrl-c to quit)

http://localhost:9160/

testing, testing; one, two, three

#+begin_src haskell-ng :results output
disp unitExample
#+end_src

#+RESULTS:
: True

** dataframe creation

*** direct method

#+begin_src haskell-ng :results output :exports both
df0 = mempty |> D.insert "item" ["person","woman","man","camera","tv"] |> D.insert "value" [20,23.1,31,16,10]
v = F.col @Double "value"
xs = D.columnAsList @Double "value" df0
xs' = (/ sum xs) <$> xs
df = D.insert "prop" xs' df0
df
#+end_src

#+RESULTS:
#+begin_example
-------------------------------------
 item  | value  |        prop
-------|--------|--------------------
[Char] | Double |       Double
-------|--------|--------------------
person | 20.0   | 0.1998001998001998
woman  | 23.1   | 0.2307692307692308
man    | 31.0   | 0.3096903096903097
camera | 16.0   | 0.15984015984015984
tv     | 10.0   | 9.99000999000999e-2
#+end_example

*** expr method

#+begin_src haskell-ng :results output :exports both
df0 = mempty |> D.insert "item" ["person","woman","man","camera","tv"] |> D.insert "value" [20,23.1,31,16,10]
v = F.col @Double "value"
prop e = e / F.sum e
df = D.derive "prop" (prop v) df0
df
#+end_src

#+RESULTS:
#+begin_example
--------------------------------------
 item  | value  |         prop
-------|--------|---------------------
[Char] | Double |        Double
-- . show) id) (D.columnAsDoubleVector e df)
-----|--------|---------------------
person | 20.0   | 0.16652789342214822
woman  | 23.1   | 0.1923397169025812
man    | 31.0   | 0.2581182348043297
camera | 16.0   | 0.13322231473771856
tv     | 10.0   | 8.326394671107411e-2
#+end_example

*** F.sum bug?

#+begin_src haskell-ng :results output :exports both
df0 = mempty |> D.insert "value" [20,23.1,31,16,10]
v = F.col @Double "value"
df = D.derive "sum" (F.sum v) df0
df
#+end_src

#+RESULTS:
#+begin_example
---------------
value  |  sum
-------|-------
Double | Double
-------|-------
20.0   | 120.1
23.1   | 120.1
31.0   | 120.1
16.0   | 120.1
10.0   | 120.1
#+end_example


** stacked bar

*** version 1: single stacked vertical bar chart

#+begin_src haskell-ng :results output :exports both
ls = T.pack <$> D.columnAsList @String "item" df
vs = D.columnAsList @Double "prop" df
bd = BarData (fmap pure vs) ["item"] ls
bd
#+end_src

#+RESULTS:
: BarData {barData = [[0.16652789342214822],[0.1923397169025812],[0.2581182348043297],[0.13322231473771856],[8.326394671107411e-2]], barRowLabels = ["item"], barColumnLabels = ["person","woman","man","camera","tv"]}

#+begin_src haskell-ng :file other/bar1.svg :results output graphics file :exports both
bc = barChart (defaultBarOptions |> set #displayValues False |> set #barStacked Stacked |> set (#barRectStyles % each % #borderSize) 0) bd
disp bc
writeChartOptions "other/bar1.svg" bc
#+end_src

#+RESULTS:
[[file:other/bar1.svg]]

*** version 2: skinny

#+begin_src haskell-ng :file other/bar2.svg :results output graphics file :exports both
bc' = Lens.transformOnOf Lens.template Lens.uniplate (over chroma' (*1.5) .> over opac' (*0.6)) bc |> set (#markupOptions % #chartAspect) (FixedAspect 0.4)

disp (bc')
writeChartOptions "other/bar2.svg" bc'
#+end_src

#+RESULTS:
[[file:other/bar2.svg]]

*** version 3: remove legend and embed labels

#+begin_src haskell-ng :file other/bar3.svg :results output graphics file :exports both

acc0 = List.scanl' (+) 0 vs <> [1]
mids = zipWith (\a0 a1 -> (a0+a1)/2) acc0 (List.drop 1 acc0)
ct = zipWith (\c (t,a) -> TextChart (defaultTextStyle |> set #size 0.05 |> set #color (palette c |> over lightness' (*0.6))) [(t, Point zero (0.5-a))]) [0..] (zip ls mids)

bc'' = bc' |> set (#hudOptions % #legends) mempty |> over #chartTree (<> named "labels" ct)

disp (bc'')
writeChartOptions "other/bar3.svg" bc''

#+end_src

#+RESULTS:
[[file:other/bar3.svg]]


** pie secants

Pie chart convention starts at the y-axis and lays out secant slices clockwise.

`ra` maps (0,1) (the proportional pie slice) into a point on a unit circle (by this convetion).

#+begin_src haskell-ng :results output
ra = (+(-0.25)) .> (*(-2 * pi)) .> ray @(Point Double)
secantPie (Secant o r a0 a1) = singletonPie o (ArcPosition (o N.+ ra a0) (o N.+ ra a1) (ArcInfo (Point r r) 0 False True))
#+end_src

#+RESULTS:

This is a very common scan for a Column.

#+begin_src haskell-ng
-- :file other/pie.svg :results output graphics file :exports both
ls = T.pack <$> D.columnAsList @String "item" df
vs = D.columnAsList @Double "prop" df
acc0 = List.scanl' (+) 0 vs <> [1]
mids = zipWith (\a0 a1 -> (a0+a1)/2) acc0 (List.drop 1 acc0)

xs = zipWith (\a0 a1 -> secantPie (Secant (0.05 N.*| ra ((a0+a1)/2)) one a0 a1)) acc0 (List.drop 1 acc0)

cs = zipWith (\c x -> PathChart (defaultPathStyle |> set #borderSize 0 |> set #color (paletteO c 0.3)) x) [0..] xs

ct = zipWith (\c (t,a) -> TextChart (defaultTextStyle |> set #size 0.05 |> set #color (palette c & over lightness' (*0.6))) [(t, 0.7 N.*| ra a)]) [0..] (zip ls mids)
co = (mempty :: ChartOptions) & set (#markupOptions % #chartAspect) ChartAspect & set #chartTree ((cs <> ct) |> unnamed)
disp co
writeChartOptions "other/pie.svg" co
#+end_src

#+RESULTS:
: True


[[file:other/pie.svg]]

* kaggle example
** dataframe check

#+begin_src haskell-ng :results output
D.describeColumns df
D.summarize df
#+end_src

#+RESULTS:
#+begin_example
-----------------------------------------------------------------
    Column Name      | # Non-null Values | # Null Values |  Type
---------------------|-------------------|---------------|-------
        Text         |        Int        |      Int      |  Text
---------------------|-------------------|---------------|-------
grade_subgrade       | 254569            | 0             | Text
loan_purpose         | 254569            | 0             | Text
employment_status    | 254569            | 0             | Text
education_level      | 254569            | 0             | Text
marital_status       | 254569            | 0             | Text
gender               | 254569            | 0             | Text
interest_rate        | 254569            | 0             | Double
loan_amount          | 254569            | 0             | Double
credit_score         | 254569            | 0             | Int
debt_to_income_ratio | 254569            | 0             | Double
annual_income        | 254569            | 0             | Double
id                   | 254569            | 0             | Int
#+end_example

* chart dev

** piePlot

Pie chart convention starts at the y-axis and lays out secant slices clockwise.

`ra` maps (0,1) (the proportional pie slice) into a point on a unit circle (by this convetion).

#+begin_src haskell-ng :results output
ra = (+(-0.25)) .> (*(-2 * pi)) .> ray @(Point Double)
secantPie (Secant o r a0 a1) = singletonPie o (ArcPosition (o N.+ ra a0) (o N.+ ra a1) (ArcInfo (Point r r) 0 False True))
#+end_src

#+RESULTS:

This is a very common scan for a Column.

#+begin_src haskell-ng
-- :file other/pie.svg :results output graphics file :exports both
ls = T.pack <$> D.columnAsList @String "item" df
vs = D.columnAsList @Double "prop" df

acc0 = List.scanl' (+) 0 vs <> [1]
mids = zipWith (\a0 a1 -> (a0+a1)/2) acc0 (List.drop 1 acc0)

xs = zipWith (\a0 a1 -> secantPie (Secant (0.05 N.*| ra ((a0+a1)/2)) one a0 a1)) acc0 (List.drop 1 acc0)

cs = zipWith (\c x -> PathChart (defaultPathStyle |> set #borderSize 0 |> set #color (paletteO c 0.3)) x) [0..] xs

ct = zipWith (\c (t,a) -> TextChart (defaultTextStyle |> set #size 0.05 |> set #color (palette c & over lightness' (*0.6))) [(t, 0.7 N.*| ra a)]) [0..] (zip ls mids)
co = (mempty :: ChartOptions) & set (#markupOptions % #chartAspect) ChartAspect & set #chartTree ((cs <> ct) |> unnamed)
disp co
writeChartOptions "other/pie.svg" co
#+end_src

#+RESULTS:
: True


[[file:other/pie.svg]]



** histPlot example

#+begin_src haskell-ng :results output
c0 = (either (error . show) id) (D.columnAsDoubleVector "interest_rate" df)
-- ch = boxPlot defaultBoxPlotOptions c0
-- writeChartOptions "other/box1.svg" ch
-- disp ch
VU.length c0
#+end_src

#+RESULTS:
: 254569

#+begin_src haskell-ng :results output
grain = 10
r = N.unsafeSpace1 $ VU.toList c0 :: (Range Double)
hcuts = N.gridSensible N.OuterPos False r grain
h = N.fill hcuts (VU.toList c0)
rects = filter (\(Rect _ _ _ y') -> y' /= 0) $ N.makeRects (N.IncludeOvers (N.width r / fromIntegral grain)) h
h = named "histogram" [RectChart (defaultRectStyle |> set #color (paletteO 2 0.2) |> set #borderColor (paletteO 2 1)) rects]

disp <| (mempty |> set #chartTree h |> set #hudOptions (mempty |> set #axes [Priority 5 (defaultXAxisOptions |> set (#ticks % #lineTick) Nothing)] |> set #titles [ (defaultTitleOptions "interest_rate" |> set #place PlaceBottom |> set (#style % #size) 0.08 |> set (#style % #color) (paletteO 2 1) |> Priority 8)]))

#+end_src

#+RESULTS:
: True

#+begin_src haskell-ng :file other/hist.svg :results output graphics file :exports both
h = histPlot defaultHistPlotOptions (Just "interest_rate", c0)
disp h
writeChartOptions "other/hist.svg" h
#+end_src

#+RESULTS:
[[file:other/hist.svg]]
#+begin_src haskell-ng :results output

e = "annual_income"
c = (either (error . show) id) (D.columnAsDoubleVector e df)
h = histPlot defaultHistPlotOptions (Just e, c)
disp h
#+end_src

#+RESULTS:
: True
: ob-haskell-ng-eoe

** boxPlot example

#+begin_src haskell-ng :results output
c0 = (either (error . show) id) (D.columnAsDoubleVector "interest_rate" df)
ch = boxPlot defaultBoxPlotOptions c0
writeChartOptions "other/box1.svg" ch
disp ch
#+end_src

#+RESULTS:
: True

[[file:other/box1.svg]]

** scatterPlot example


#+RESULTS:
: True

#+begin_src haskell-ng :results output
c0 = (either (error . show) id) (D.columnAsDoubleVector "interest_rate" df)
c1 = (either (error . show) id) (D.columnAsDoubleVector "loan_amount" df)

ch = GlyphChart defaultGlyphStyle (Prelude.take 1000 $ zipWith Point (VU.toList c0) (VU.toList c1))

ch' = (mempty :: ChartOptions) & set #chartTree (named "scatterPlot" [ch]) & set #hudOptions defaultHudOptions & set (#hudOptions % #titles) [(Priority 8 (defaultTitleOptions "interest_rate" & set #place PlaceBottom & set (#style % #size) 0.06)),(Priority 8 (defaultTitleOptions "loan_amount" & set #place PlaceLeft & set (#style % #size) 0.06 & set #buffer 0.1))]

writeChartOptions "other/scatter1.svg" ch'
disp ch'
#+end_src

#+RESULTS:
: True


Using MData.scatterPlot

#+begin_src haskell-ng :results output
v0 = (either (error . show) id) (D.columnAsDoubleVector "interest_rate" df)
v1 = (either (error . show) id) (D.columnAsDoubleVector "loan_amount" df)
ch = scatterPlot defaultScatterPlotOptions (Just "interest_rate", v0) (Just "loan_amount", v1)

writeChartOptions "other/scatter1.svg" ch
disp ch
#+end_src

#+RESULTS:
: True

[[file:other/scatter1.svg]]

* reference

Comparable python:

https://www.kaggle.com/code/ravitejagonnabathula/predicting-loan-payback

notebook best practice:

https://marimo.io/blog/lessons-learned

converting to ipynb:

https://pandoc.org/installing.html

#+begin_src sh :results output
pandoc readme.md -o mdata.ipynb
#+end_src

chart-svg api tree

https://hackage-content.haskell.org/package/chart-svg-0.8.2.1/docs/other/ast.svg

* (deprecated) testing snippets

** file read testing

It's a good chunky first example.

#+begin_src haskell-ng :results output
s <- readFile "other/test.csv"
length s
#+end_src

#+RESULTS:
: 23021430

#+begin_src haskell-ng :results output
rf = readFile "other/test.csv"
(m,n) <- tickIO (length <$> rf)
print n
toSecs m
#+end_src

#+RESULTS:
: 23021430
: 0.144087667

#+begin_src haskell-ng :results output
(m,df) <- tickIO (D.readCsv "other/test.csv")
print $ toSecs m
:t df
#+end_src

#+RESULTS:
: 0.944859458
: df :: DataFrame


Example data is  from https://www.kaggle.com/competitions/playground-series-s5e11
** get a Column and compute quartiles.

#+begin_src haskell-ng :results output
c = (either (error . show) id) (columnAsDoubleVector "interest_rate" df)
:t c
q4s = VU.toList $ quantiles' (VU.fromList [0,1,2,3,4]) 4 c
:t q4s
q4s
#+end_src

#+RESULTS:
: c :: VU.Vector Double
: q4s :: [Double]
: [3.2,10.98,12.37,13.69,21.29]

** box plot constructor

A box plot is:

- (maybe) a vertical tick at the min
- a LineChart from min to q1
- a RectChart from q1 to q2
- a RectChart from q2 to q3
- a LineChart q3 to max
- (maybe) a vertical tick at the max

#+begin_src haskell-ng :results output
l1 = LineChart defaultLineStyle [[Point (q4s !! 0) 0.5, Point (q4s !! 1) 0.5]]
l2 = LineChart defaultLineStyle [[Point (q4s !! 3) 0.5, Point (q4s !! 4) 0.5]]
r1 = RectChart defaultRectStyle [Rect (q4s !! 1) (q4s !! 2) 0 1]
r2 = RectChart defaultRectStyle [Rect (q4s !! 2) (q4s !! 3) 0 1]
#+end_src

#+RESULTS:

#+begin_src haskell-ng :results output
c = (mempty :: ChartOptions) & set #hudOptions defaultHudOptions & set #chartTree (unnamed [l1,r1,r2,l2])
#+end_src

#+RESULTS:

#+begin_src haskell-ng :results output
disp c
#+end_src

#+RESULTS:
: True

#+begin_src haskell-ng :results output
writeChartOptions "other/c.svg" c
#+end_src

#+RESULTS:

[[file:other/c.svg]]

** vertical version

#+begin_src haskell-ng :results output
qs = q4s
l1 = LineChart defaultLineStyle [[Point 0.5 (qs !! 0), Point 0.5 (qs !! 1)]]
l2 = LineChart defaultLineStyle [[Point 0.5 (qs !! 3), Point 0.5 (qs !! 4)]]
r1 = RectChart defaultRectStyle [Rect 0 1 (qs !! 1) (qs !! 2)]
r2 = RectChart defaultRectStyle [Rect 0 1 (qs !! 2) (qs !! 3)]
#+end_src

#+RESULTS:

#+begin_src haskell-ng :results output
c = (mempty :: ChartOptions) & set (#markupOptions % #chartAspect) (FixedAspect 0.25) & set #hudOptions defaultHudOptions & over (#hudOptions % #axes) (Prelude.drop 1) & set #chartTree (named "boxplot" [l1,r1,r2,l2])
disp c
#+end_src

#+RESULTS:
: True

* initial build

#+begin_src sh :results output
cabal init  --non-interactive mdata -d "base,dataframe,perf,chart-svg,prettychart,vector"
#+end_src
